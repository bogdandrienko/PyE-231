"""
https://proglib.io/p/slozhnost-algoritmov-i-operaciy-na-primere-python-2020-11-03
"Сложность алгоритмов и операций на примере Python.html"

«O» большое служит обозначением временной сложности операций алгоритма. Она показывает, сколько времени потребуется
алгоритму для вычисления требуемой операции.
На письме временная сложность алгоритма обозначается как O(n), где n — размер входной коллекции.

O(1)
Обозначение константной временной сложности. Независимо от размера коллекции, время, необходимое для выполнения
операции, константно.

O(log n)
Обозначение логарифмической временной сложности. В этом случае когда размер коллекции увеличивается, время,
необходимое для выполнения операции, логарифмически увеличивается.

O(n)
Обозначение линейной временной сложности. Время, необходимое для выполнения операции, прямо и линейно пропорционально
количеству элементов в коллекции.

O(n log n)
Обозначение квазилинейной временной сложности. Скорость выполнения операции является квазилинейной функцией числа
элементов в коллекции.

O(n^2)
Обозначение квадратичной временной сложности. Время, необходимое для выполнения операции, пропорционально квадрату
элементов в коллекции.

O(n!)
Обозначение факториальной временной сложности. Каждая операция требует вычисления всех перестановок коллекции,
следовательно, требуемое время выполнения операции является факториалом размера входной коллекции.
"""

"""
Благоприятные, средние и худшие случаи
При вычислении временной сложности операции можно получить сложность на основе благоприятного, среднего или худшего 
случая.

Благоприятный случай. Как следует из названия, это сценарий, когда структуры данных и элементы в коллекции вместе с 
параметрами находятся в оптимальном состоянии. Например, мы хотим найти элемент в коллекции. Если этот элемент 
оказывается первым элементом коллекции, то это лучший сценарий для операции.

Средний случай. Определяем сложность на основе распределения значений входных данных.

Худший случай. Структуры данных и элементы в коллекции вместе с параметрами находятся в наиболее неоптимальном 
состоянии. Например, худший случай для операции, которой требуется найти элемент в большой коллекции в виде списка — 
когда искомый элемент находится в самом конце, а алгоритм перебирает коллекцию с самого начала.
"""

"""
Коллекции Python и их временная сложность - 

* Список (list):
Вставка: O(n).
Получение элемента: O(1).
Удаление элемента: O(n).
Проход: O(n).
Получение длины: O(1)

* Множество (set)
Проверить наличие элемента в множестве: O(1).
Отличие множества A от B: O(длина A).
Пересечение множеств A и B: O(минимальная длина A или B).
Объединение множеств A и B: O(N) , где N это длина (A) + длина (B).

* Словарь (dict)
Получение элемента: O(1).
Установка элемента: O(1).
Удаление элемента: O(1).
Проход по словарю: O(n).
"""

"""

    # set() | dict()
    # O(1) = 1s - константное время выполнения
    # O(logN) = 10s - линейное время выполнения
    # O(N) = 100s - линейное время выполнения
    # O(N*2) = 200s - 2x линейное время выполнения
    # O(NlogN) = 1000s - линейное время выполнения
    # O(N^2) = 10000s - квадратичное время выполнения
    # O(N!2) = s - ...

    # преждевременная оптимизация
    # рефакторинг

    # print("Заняло времени: ", round(time.perf_counter() - time_start, 3))

    # Сортировка    l.sort()    O(N Log N)

    # https://proglib.io/p/slozhnost-algoritmov-i-operaciy-na-primere-python-2020-11-03
    # https://machinelearningmastery.ru/understanding-time-complexity-with-python-examples-2bda6e8158a7/
    # https://habr.com/ru/companies/kts/articles/727528/

    # https://www.youtube.com/watch?v=Pp84Sv041xA&t=18594s&ab_channel=%D0%93%D0%BB%D0%B5%D0%B1%D0%9C%D0%B8%D1%85%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2

    # бинарное дерево - (красные/чк деревья)

    #
    # обычный поиск, для 240 000 элементов, где 1 шаг стоит 1s, в худшем случае 240 000s
    # бинарный поиск, для 240 000 элементов, где 1 шаг стоит 1s, в худшем случае 18s
    #

"""

########################################################################################################################



########################################################################################################################

########################################################################################################################
# TODO бинарное дерево


class BinaryTree:
    def __init__(self, data: int):
        self.left = None
        self.right = None
        self.root = data

    def get_data(self):
        return self.root

    def insert_new_data(self, data: int):
        if self.root:
            if data < self.root:
                # левый
                if self.left is not None:
                    self.left.insert_new_data(data)
                else:
                    self.left = BinaryTree(data)
                # левый

            elif data > self.root:
                # правый
                if self.right is not None:
                    self.right.insert_new_data(data)
                else:
                    self.right = BinaryTree(data)
                # правый

            else:
                print("Значение повторяется")

        else:
            self.root = data

    def print_all_edges(self):
        print(self.root)
        print(self.left)
        print(self.right)


tree1 = BinaryTree(1)  # создание экземляра класса - создание объекта
tree1.insert_new_data(2)
tree1.insert_new_data(3)
tree1.insert_new_data(9)
tree1.insert_new_data(6)
tree1.insert_new_data(11)
tree1.insert_new_data(15)
print(f"root: {tree1.root}")
print(f"root: {tree1.right.root}")

print(f"root: {tree1.right.right.root}")

print(f"root: {tree1.right.right.right.root}")

print(f"root: {tree1.right.right.right.right.root}")
print(f"root: {tree1.right.right.right.left.root}")

print(f"root: {tree1.right.right.right.right.right.root}")

########################################################################################################################


